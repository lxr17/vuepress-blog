(window.webpackJsonp=window.webpackJsonp||[]).push([[111],{383:function(a,t,v){"use strict";v.r(t);var l=v(10),_=Object(l.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"基础知识-java篇"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础知识-java篇"}},[a._v("#")]),a._v(" 基础知识（Java篇）")]),a._v(" "),t("h2",{attrs:{id:"gc机制-垃圾回收机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gc机制-垃圾回收机制"}},[a._v("#")]),a._v(" GC机制（垃圾回收机制）")]),a._v(" "),t("ul",[t("li",[a._v("找到垃圾的方法：引用计数法、可达性分析法")]),a._v(" "),t("li",[a._v("回收垃圾的方法：标记清除算法、复制算法、标记整理法、分代算法")])]),a._v(" "),t("h2",{attrs:{id:"jvm内存划分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm内存划分"}},[a._v("#")]),a._v(" JVM内存划分")]),a._v(" "),t("ul",[t("li",[a._v("线程私有：程序计数器、JVM虚拟机栈、本地方法栈")]),a._v(" "),t("li",[a._v("线程公有：堆、方法区、运行时常量池")])]),a._v(" "),t("h2",{attrs:{id:"会发生oom的区域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#会发生oom的区域"}},[a._v("#")]),a._v(" 会发生OOM的区域")]),a._v(" "),t("ul",[t("li",[a._v("堆：内存泄漏")]),a._v(" "),t("li",[a._v("JVM虚拟机栈和本地方法栈：递归循环")]),a._v(" "),t("li",[a._v("方法区：早期类加载过多会OOM，现在一般不会")])]),a._v(" "),t("h2",{attrs:{id:"类加载过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载过程"}},[a._v("#")]),a._v(" 类加载过程")]),a._v(" "),t("ol",[t("li",[a._v("加载：将字节码数据从不同的数据源读取到JVM内存，并映射为JVM认可的数据结构")]),a._v(" "),t("li",[a._v("链接：\n"),t("ol",[t("li",[a._v("验证：校验字节信息是否符合规范，避免恶意信息和不规范数据危害JVM运行安全")]),a._v(" "),t("li",[a._v("准备：创建静态变量，并为静态变量开辟内存空间")]),a._v(" "),t("li",[a._v("解析：将符号引用替换为直接引用")])])]),a._v(" "),t("li",[a._v("初始化：为静态变量赋值，并执行静态代码块中的逻辑")])]),a._v(" "),t("h2",{attrs:{id:"双亲委派模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派模型"}},[a._v("#")]),a._v(" 双亲委派模型")]),a._v(" "),t("ol",[t("li",[a._v("类加载器分类\n"),t("ul",[t("li",[a._v("启动类加载器：主要加载jre/lib下的jar文件")]),a._v(" "),t("li",[a._v("扩展类加载器：主要加载jre/lib/ext下的jar文件")]),a._v(" "),t("li",[a._v("应用程序类加载器：主要加载classpath下的文件")])])]),a._v(" "),t("li",[a._v("双亲委派模型：当加载一个类时，优先使用父类加载器加载，当父类加载器无法加载时才使用子类加载器去加载")])]),a._v(" "),t("h2",{attrs:{id:"hashmap的原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap的原理"}},[a._v("#")]),a._v(" HashMap的原理")]),a._v(" "),t("ul",[t("li",[a._v("可以看作是数组+链表的组合。数组被分为一个个的桶。哈希值决定了键值对在数组中的寻址。具有相同哈希值的键值对会组成链表（避免哈希冲突）。当链表长度超过阈值（默认是8）的时候会触发树化，链表会变成树形结构。")])]),a._v(" "),t("h2",{attrs:{id:"hashmap需要关注的4个方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap需要关注的4个方法"}},[a._v("#")]),a._v(" HashMap需要关注的4个方法")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("hash方法")]),a._v(" "),t("ul",[t("li",[a._v("将key的hashCode值的高位数据移位到低位进行异或运算。这么做的原因是有些key的hashCode值的差异集中在高位，而哈希寻址是忽略容量以上高位的，这种做法可以有效避免哈希冲突")])])]),a._v(" "),t("li",[t("p",[a._v("put方法（步骤）")]),a._v(" "),t("ol",[t("li",[a._v("通过hash方法获取hash值，根据hash值寻址")]),a._v(" "),t("li",[a._v("如果未发生碰撞，直接放到桶中")]),a._v(" "),t("li",[a._v("如果发生碰撞，则以链表形式放在桶后")]),a._v(" "),t("li",[a._v("当链表长度大于阈值后会触发树化，将链表转换为红黑树")]),a._v(" "),t("li",[a._v("如果数组长度达到阈值，会调用resize方法扩容")])])]),a._v(" "),t("li",[t("p",[a._v("get方法（步骤）")]),a._v(" "),t("ol",[t("li",[a._v("通过hash方法获取hash值，根据hash值寻址")]),a._v(" "),t("li",[a._v("如果与寻址到桶的key相同，直接返回对应的value")]),a._v(" "),t("li",[a._v("如果发生冲突，分两种情况。如果是树，则调用getTreeNode获取value；如果是链表，则循环遍历查找对应的value")])])]),a._v(" "),t("li",[t("p",[a._v("resize方法（步骤）")]),a._v(" "),t("ol",[t("li",[a._v("将原数组扩展为原来的2倍")]),a._v(" "),t("li",[a._v("重新计算index索引值，将原节点重新放到新的数组中。这一步可以将原先冲突的节点分散到新的桶中")])])])]),a._v(" "),t("h2",{attrs:{id:"sleep和wait的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sleep和wait的区别"}},[a._v("#")]),a._v(" sleep和wait的区别")]),a._v(" "),t("ul",[t("li",[a._v("sleep方法是Thread类中的静态方法，wait是Object类中的方法")]),a._v(" "),t("li",[a._v("sleep并不会释放同步锁，而wait会释放同步锁")]),a._v(" "),t("li",[a._v("sleep可以在任何地方使用，而wait方法只能在同步方法或者同步方法块中使用")]),a._v(" "),t("li",[a._v("sleep中必须传入时间，而wait可以传也可以不传，不传时间的话只有notify或者notifyAll才能唤醒，传时间的话在时间之后会自动唤醒")])]),a._v(" "),t("h2",{attrs:{id:"final、finally、finalize的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#final、finally、finalize的区别"}},[a._v("#")]),a._v(" final、finally、finalize的区别")]),a._v(" "),t("ul",[t("li",[a._v("final可以修饰类、变量和方法。修饰类代表这个类不可被继承，修饰变量代表此变量不可被改变，修饰方法表示此方法不可被重写（override）")]),a._v(" "),t("li",[a._v("finally是保证重点代码一定会执行的一种机制。通常是使用try-finally或者try-catch-finally来进行文件流的关闭等操作")]),a._v(" "),t("li",[a._v("finalize是Object类中的一个方法。它的设计目的是保证对象在垃圾回收前完成特定资源的回收。finalize机制已不推荐使用，并且在JDK9已经被标记为deprecated")])]),a._v(" "),t("h2",{attrs:{id:"常见的单例模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见的单例模式"}},[a._v("#")]),a._v(" 常见的单例模式")]),a._v(" "),t("ul",[t("li",[a._v("饿汉式、双重判断的懒汉式、静态内部类实现的单例（"),t("span",{staticStyle:{color:"#ff0000"}},[a._v("最推荐的方式")]),a._v("）、枚举实现的单例")])]),a._v(" "),t("p",[t("span",{staticStyle:{"background-color":"#ffff00"}},[a._v("单例对象实例需要有volatile修饰，是因为：mInstance = new SingleTon()包含三个操作（给mInstance分配内存，调用SingleTon的构造方法初始化成员变量，将mInstance指向分配的内存空间），又由于JVM会发生指令重排，所以可能调用顺序会发生错误。这样会导致报错。而volatile的作用有保持可见性和禁止指令重排")])]),a._v(" "),t("h2",{attrs:{id:"java中引用类型的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java中引用类型的区别"}},[a._v("#")]),a._v(" java中引用类型的区别")]),a._v(" "),t("ul",[t("li",[a._v("强引用：指的是通过new对象创建的引用，垃圾回收器即使在内存不足的情况下也不会回收具有强引用的对象")]),a._v(" "),t("li",[a._v("软引用：是通过SoftRefrence实现的，在内存不足之前会被垃圾回收器回收。可用于存储一些内存敏感的缓存")]),a._v(" "),t("li",[a._v("弱引用：是通过WeakRefrence实现的，垃圾回收器只要扫描到就会将其回收。可用于存储一些内存敏感的缓存")]),a._v(" "),t("li",[a._v("虚引用：是通过FanttomRefrence实现的，随时有可能被回收。可用于跟踪对象被垃圾回收的活动，当一个虚引用关联的对象被GC回收之前会受到一条系统通知")])]),a._v(" "),t("h2",{attrs:{id:"volatile的原理是在生成的汇编代码中多了一个lock前缀指令-这个前缀指令相当于一个内存屏障-这个屏障有三个作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#volatile的原理是在生成的汇编代码中多了一个lock前缀指令-这个前缀指令相当于一个内存屏障-这个屏障有三个作用"}},[a._v("#")]),a._v(" volatile的原理是在生成的汇编代码中多了一个lock前缀指令，这个前缀指令相当于一个内存屏障，这个屏障有三个作用")]),a._v(" "),t("ol",[t("li",[a._v("确保指令重排的时候不会把屏障后的指令排在屏障前，确保不会把屏障前的指令排在屏障后")]),a._v(" "),t("li",[a._v("修改缓存中的共享变量后立即刷新到主存中")]),a._v(" "),t("li",[a._v("当执行写操作时会导致其他CPU中的缓存无效")])]),a._v(" "),t("h2",{attrs:{id:"http与https的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http与https的区别"}},[a._v("#")]),a._v(" http与https的区别")]),a._v(" "),t("ul",[t("li",[a._v("https需要CA证书，很少免费，需要一定费用")]),a._v(" "),t("li",[a._v("http是明文传输，安全性低；而https是http的基础上通过ssl加密，安全性高")]),a._v(" "),t("li",[a._v("默认端口不同。http是80，https是443")])]),a._v(" "),t("h2",{attrs:{id:"https的加密算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https的加密算法"}},[a._v("#")]),a._v(" https的加密算法")]),a._v(" "),t("ul",[t("li",[a._v("称加密：加密和解密用的都是相同的秘钥，优点是速度快，缺点是安全性低。常见的算法有DES、AES等等")]),a._v(" "),t("li",[a._v("非对称加密：非对称加密有一个密钥对，分为公钥和私钥。一般来说，私钥自己持有，公钥可以公开给对方，优点是安全性比对称加密高，缺点是数据传输效率比对称加密低。采用公钥加密的信息只有对应的私钥可以解密。常见的算法有RSA等")])]),a._v(" "),t("p",[t("span",{staticStyle:{"background-color":"#ffff00",color:"#000000"}},[a._v("正式场景中一般都是采用对称加密和非对称加密结合的方式，使用非对称加密来完成秘钥的传递，然后使用对称加密实现数据的传递。这样保证了安全性又提高了传输效率")])])])}),[],!1,null,null,null);t.default=_.exports}}]);